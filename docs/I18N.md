# Internationalization (i18n) Guide

This document provides comprehensive guidance on ArisuTalk's internationalization system, including implementation details, usage patterns, and guidelines for adding new languages.

## Table of Contents
1. [Overview](#overview)
2. [System Architecture](#system-architecture)
3. [Language Files](#language-files)
4. [Translation Functions](#translation-functions)
5. [Implementation Patterns](#implementation-patterns)
6. [Adding New Languages](#adding-new-languages)
7. [Best Practices](#best-practices)
8. [Troubleshooting](#troubleshooting)

## Overview

ArisuTalk features a comprehensive internationalization system that supports real-time language switching without page refresh. The system is built on a centralized translation architecture with extensive coverage across all application components.

### Supported Languages
- **Korean (ko)** - Primary language with complete coverage
- **English (en)** - Full translation with native speaker quality
- **Extensible** - Architecture supports easy addition of new languages

### Key Features
- **Real-time Language Switching** - Instant language changes without page reload
- **Comprehensive Coverage** - All UI elements, API messages, and system notifications
- **Fallback System** - Graceful degradation when translations are missing
- **Context-Aware Translations** - Contextual translations for better accuracy
- **Dynamic Content Support** - Translations for dynamically generated content

## System Architecture

### Core Components

```
i18n System Architecture
├── Core Module (i18n.js)
│   ├── Language Detection
│   ├── Translation Function (t())
│   ├── Language Switching Logic
│   └── Fallback Handling
├── Language Files
│   ├── Korean (ko.js)
│   └── English (en.js)
├── Integration Points
│   ├── Component Templates
│   ├── API Integration
│   ├── Dynamic Content
│   └── Error Messages
└── UI Components
    ├── Language Selector
    ├── Real-time Updates
    └── Preference Storage
```

### Translation Flow

```mermaid
graph TD
    A[Component Needs Text] --> B[Call t() Function]
    B --> C[Check Current Language]
    C --> D[Lookup Translation Key]
    D --> E{Key Exists?}
    E -->|Yes| F[Return Translation]
    E -->|No| G[Check Fallback Language]
    G --> H{Fallback Exists?}
    H -->|Yes| I[Return Fallback]
    H -->|No| J[Return Key as Fallback]
    F --> K[Display Text]
    I --> K
    J --> K
```

## Language Files

### File Structure

Language files are located in `frontend/src/language/` and follow a hierarchical structure:

```javascript
// ko.js or en.js
export const translations = {
    // User Interface Elements
    ui: {
        buttons: {
            save: "저장",
            cancel: "취소",
            delete: "삭제"
        },
        labels: {
            name: "이름",
            description: "설명"
        },
        placeholders: {
            enterName: "이름을 입력하세요"
        }
    },
    
    // API Integration
    api: {
        errors: {
            networkError: "네트워크 오류가 발생했습니다",
            invalidResponse: "잘못된 응답입니다"
        },
        success: {
            dataSaved: "데이터가 저장되었습니다"
        }
    },
    
    // Modal Components
    modal: {
        character: {
            title: "캐릭터 설정",
            nameLabel: "캐릭터 이름"
        },
        settings: {
            title: "설정",
            closeButton: "닫기"
        }
    },
    
    // Settings Panels
    settings: {
        api: {
            title: "API 설정",
            provider: "제공업체",
            model: "모델"
        },
        appearance: {
            title: "외관 설정",
            theme: "테마",
            language: "언어"
        }
    }
};
```

### Key Naming Conventions

1. **Hierarchical Structure**: Use nested objects to organize related translations
2. **Descriptive Names**: Keys should clearly indicate their purpose and context
3. **Consistent Naming**: Follow camelCase for keys
4. **Context Prefixes**: Use prefixes to indicate the component or section

```javascript
// Good examples
ui.buttons.save
modal.character.title
settings.api.provider
api.errors.networkError

// Avoid
save_button
characterModalTitle
providerSetting
network_error
```

## Translation Functions

### Basic Usage

The primary translation function is `t()`, which retrieves translated text based on keys:

```javascript
import { t } from './i18n.js';

// Basic translation
const saveButton = t('ui.buttons.save');

// With fallback
const customText = t('custom.key', 'Default Text');

// Dynamic content
const welcomeMessage = t('ui.welcome', `Welcome, ${userName}!`);
```

### Function Signature

```javascript
/**
 * Translate a key to the current language
 * @param {string} key - Translation key (dot notation)
 * @param {string} fallback - Fallback text if key not found
 * @param {Object} params - Parameters for dynamic content
 * @returns {string} Translated text
 */
function t(key, fallback = null, params = {}) {
    // Implementation details
}
```

### Advanced Usage

#### Parameter Substitution

```javascript
// Language file
export const translations = {
    messages: {
        itemCount: "{{count}}개의 항목이 있습니다"
    }
};

// Usage
const message = t('messages.itemCount', null, { count: 5 });
// Result: "5개의 항목이 있습니다"
```

#### Conditional Translations

```javascript
// Language file
export const translations = {
    status: {
        online: "온라인",
        offline: "오프라인"
    }
};

// Usage
const statusText = t(`status.${isOnline ? 'online' : 'offline'}`);
```

## Implementation Patterns

### Component Integration

#### HTML Templates

```javascript
function generateSettingsHTML() {
    return `
        <div class="settings-panel">
            <h2>${t('settings.title')}</h2>
            <label>${t('settings.api.provider')}</label>
            <input placeholder="${t('settings.api.providerPlaceholder')}">
            <button>${t('ui.buttons.save')}</button>
        </div>
    `;
}
```

#### Dynamic Content Updates

```javascript
function updateLanguage() {
    // Update button texts
    document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.dataset.i18n;
        element.textContent = t(key);
    });
    
    // Update placeholders
    document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
        const key = element.dataset.i18nPlaceholder;
        element.placeholder = t(key);
    });
    
    // Update titles
    document.querySelectorAll('[data-i18n-title]').forEach(element => {
        const key = element.dataset.i18nTitle;
        element.title = t(key);
    });
}
```

### API Integration

#### Error Message Translation

```javascript
// API handler
async function handleAPICall() {
    try {
        const response = await fetch(apiUrl);
        if (!response.ok) {
            throw new Error(t('api.errors.requestFailed'));
        }
    } catch (error) {
        console.error(t('api.errors.networkError'), error);
        showNotification(t('api.errors.networkError'));
    }
}
```

#### Success Messages

```javascript
function saveSettings(settings) {
    try {
        storage.save(settings);
        showNotification(t('api.success.settingsSaved'));
    } catch (error) {
        showNotification(t('api.errors.saveFailed'));
    }
}
```

### Modal Components

```javascript
function createConfirmationModal(action) {
    const modal = document.createElement('div');
    modal.innerHTML = `
        <div class="modal-content">
            <h3>${t('modal.confirmation.title')}</h3>
            <p>${t(`modal.confirmation.${action}Message`)}</p>
            <div class="modal-actions">
                <button class="confirm">${t('ui.buttons.confirm')}</button>
                <button class="cancel">${t('ui.buttons.cancel')}</button>
            </div>
        </div>
    `;
    return modal;
}
```

## Adding New Languages

### Step 1: Create Language File

Create a new file in `frontend/src/language/` following the naming pattern:

```javascript
// frontend/src/language/fr.js (for French)
export const translations = {
    // Copy structure from ko.js or en.js
    ui: {
        buttons: {
            save: "Enregistrer",
            cancel: "Annuler",
            delete: "Supprimer"
        }
        // ... complete all translations
    }
    // ... complete all sections
};
```

### Step 2: Update i18n Configuration

Add the new language to the i18n system:

```javascript
// frontend/src/i18n.js
import { translations as ko } from './language/ko.js';
import { translations as en } from './language/en.js';
import { translations as fr } from './language/fr.js'; // Add new import

const languages = {
    ko,
    en,
    fr  // Add new language
};

const languageNames = {
    ko: '한국어',
    en: 'English',
    fr: 'Français'  // Add display name
};
```

### Step 3: Update Language Selector

Add the new language option to the language selector UI:

```javascript
// In AppearanceSettingsPanel.js or MobileSettingsModal.js
function generateLanguageSelector() {
    return `
        <div class="language-selector">
            <button data-language="ko">🇰🇷 한국어</button>
            <button data-language="en">🇺🇸 English</button>
            <button data-language="fr">🇫🇷 Français</button>
        </div>
    `;
}
```

### Step 4: Translation Guidelines

When translating to a new language:

1. **Maintain Context**: Understand the context of each key before translating
2. **Consistent Terminology**: Use consistent terms throughout the application
3. **Cultural Adaptation**: Adapt content to cultural norms when appropriate
4. **Technical Terms**: Keep technical terms consistent or use widely accepted translations
5. **Length Considerations**: Consider UI space constraints for longer languages

## Best Practices

### Translation Keys

1. **Descriptive Keys**: Use clear, descriptive key names
   ```javascript
   // Good
   'settings.api.providerSelectionTitle'
   
   // Avoid
   'apiTitle'
   ```

2. **Hierarchical Organization**: Group related translations
   ```javascript
   settings: {
       api: { /* API-related settings */ },
       appearance: { /* Appearance settings */ },
       character: { /* Character settings */ }
   }
   ```

3. **Avoid Hardcoded Text**: Always use translation keys for user-facing text
   ```javascript
   // Good
   element.textContent = t('ui.messages.success');
   
   // Avoid
   element.textContent = 'Success!';
   ```

### Performance Optimization

1. **Lazy Loading**: Load only the current language
2. **Caching**: Cache translations to avoid repeated lookups
3. **Batch Updates**: Update multiple elements together when language changes

### Error Handling

1. **Graceful Fallbacks**: Provide meaningful fallbacks
   ```javascript
   function t(key, fallback = null) {
       const translation = getTranslation(key);
       return translation || fallback || key;
   }
   ```

2. **Missing Translation Logging**: Log missing translations for debugging
   ```javascript
   if (!translation) {
       console.warn(`Missing translation for key: ${key}`);
   }
   ```

### Real-time Updates

1. **Event-Driven Updates**: Use events to trigger UI updates
   ```javascript
   window.addEventListener('languageChanged', updateUILanguage);
   ```

2. **Component Re-rendering**: Ensure components update when language changes
   ```javascript
   function onLanguageChange() {
       renderComponent();
       setupEventListeners();
   }
   ```

## Troubleshooting

### Common Issues

#### 1. Missing Translations
**Problem**: Text displays as key instead of translated text
**Solution**: Check if the key exists in the current language file

```javascript
// Debug missing translation
console.log('Translation exists:', translations[currentLanguage]?.ui?.buttons?.save);
```

#### 2. Language Not Switching
**Problem**: UI doesn't update after language change
**Solution**: Ensure components are re-rendered after language change

```javascript
function changeLanguage(newLanguage) {
    setCurrentLanguage(newLanguage);
    updateAllComponents(); // Make sure this is called
}
```

#### 3. Parameter Substitution Not Working
**Problem**: Parameters like `{{count}}` not being replaced
**Solution**: Check parameter syntax and ensure parameters are passed

```javascript
// Correct usage
t('messages.itemCount', null, { count: 5 });

// Check parameter syntax in language file
itemCount: "Found {{count}} items"
```

#### 4. Inconsistent Translations
**Problem**: Same concept translated differently in different parts
**Solution**: Create a translation glossary and use consistent terms

### Debugging Tools

1. **Translation Key Inspector**: Add data attributes to track translation keys
   ```javascript
   element.dataset.translationKey = key;
   ```

2. **Missing Translation Reporter**: Log all missing translations
   ```javascript
   const missingTranslations = new Set();
   
   function t(key, fallback) {
       if (!getTranslation(key)) {
           missingTranslations.add(key);
           console.warn(`Missing: ${key}`);
       }
   }
   ```

3. **Language Coverage Analysis**: Check translation completeness
   ```javascript
   function analyzeTranslationCoverage(referenceLanguage, targetLanguage) {
       const missing = [];
       // Compare language files and report missing keys
       return missing;
   }
   ```

## Conclusion

ArisuTalk's internationalization system provides:
- **Comprehensive Coverage**: All user-facing text is translatable
- **Real-time Switching**: Instant language changes enhance user experience
- **Developer-Friendly**: Easy to use translation functions and clear patterns
- **Extensible Architecture**: Simple to add new languages
- **Performance Optimized**: Efficient translation lookup and caching

By following this guide, developers can effectively work with the i18n system, add new languages, and maintain high-quality translations across the application.