# Internationalization (i18n) Guide

This document provides comprehensive guidance on ArisuTalk's internationalization system, including implementation details, usage patterns, and guidelines for adding new languages.

## Table of Contents
1. [Overview](#overview)
2. [System Architecture](#system-architecture)
3. [Language Files](#language-files)
4. [Translation Functions](#translation-functions)
5. [Implementation Patterns](#implementation-patterns)
6. [Adding New Languages](#adding-new-languages)
7. [Best Practices](#best-practices)
8. [Troubleshooting](#troubleshooting)

## Overview

ArisuTalk features a comprehensive internationalization system that supports real-time language switching without page refresh. The system is built on a centralized translation architecture with extensive coverage across all application components, seamlessly integrated with Svelte 5.

### Supported Languages
- **Korean (ko)** - Primary language with complete coverage
- **English (en)** - Full translation with native speaker quality
- **Extensible** - Architecture supports easy addition of new languages

### Key Features
- **Real-time Language Switching** - Instant language changes without page reload, powered by Svelte's reactivity
- **Comprehensive Coverage** - All UI elements, API messages, and system notifications
- **Fallback System** - Graceful degradation when translations are missing
- **Context-Aware Translations** - Contextual translations for better accuracy
- **Dynamic Content Support** - Translations for dynamically generated content

## System Architecture

### Core Components

```
i18n System Architecture
├── Core Module (src/i18n.ts)
│   ├── Language Detection
│   ├── Translation Function (t())
│   ├── Language Switching Logic
│   └── Fallback Handling
├── Language Files
│   ├── Korean (ko.ts)
│   └── English (en.ts)
├── Integration Points
│   ├── Svelte Component Templates
│   ├── API Integration
│   ├── Dynamic Content
│   └── Error Messages
└── UI Components
    ├── Language Selector (Svelte Component)
    ├── Real-time Updates (Svelte Reactivity)
    └── Preference Storage
```

### Translation Flow

```mermaid
graph TD
    A[Svelte Component Needs Text] --> B[Call t() Function]
    B --> C[Check Current Language]
    C --> D[Lookup Translation Key]
    D --> E{Key Exists?}
    E -->|Yes| F[Return Translation]
    E -->|No| G[Check Fallback Language]
    G --> H{Fallback Exists?}
    H -->|Yes| I[Return Fallback]
    H -->|No| J[Return Key as Fallback]
    F --> K[Display Text in Svelte Component]
    I --> K
    J --> K
```

## Language Files

### File Structure

Language files are located in `frontend/src/language/` and follow a hierarchical structure:

```typescript
// ko.ts or en.ts
export const translations = {
    // User Interface Elements
    ui: {
        buttons: {
            save: "저장",
            cancel: "취소",
            delete: "삭제"
        },
        labels: {
            name: "이름",
            description: "설명"
        },
        placeholders: {
            enterName: "이름을 입력하세요"
        }
    },
    
    // API Integration
    api: {
        errors: {
            networkError: "네트워크 오류가 발생했습니다",
            invalidResponse: "잘못된 응답입니다"
        },
        success: {
            dataSaved: "데이터가 저장되었습니다"
        }
    },
    
    // Modal Components
    modal: {
        character: {
            title: "캐릭터 설정",
            nameLabel: "캐릭터 이름"
        },
        settings: {
            title: "설정",
            closeButton: "닫기"
        }
    },
    
    // Settings Panels
    settings: {
        api: {
            title: "API 설정",
            provider: "제공업체",
            model: "모델"
        },
        appearance: {
            title: "외관 설정",
            theme: "테마",
            language: "언어"
        }
    }
};
```

### Key Naming Conventions

1. **Hierarchical Structure**: Use nested objects to organize related translations
2. **Descriptive Names**: Keys should clearly indicate their purpose and context
3. **Consistent Naming**: Follow camelCase for keys
4. **Context Prefixes**: Use prefixes to indicate the component or section

```typescript
// Good examples
ui.buttons.save
modal.character.title
settings.api.provider
api.errors.networkError

// Avoid
save_button
characterModalTitle
providerSetting
network_error
```

## Translation Functions

### Basic Usage

The primary translation function is `t()`, which retrieves translated text based on keys:

```typescript
import { t } from '../i18n'; // Assuming i18n.ts is in the parent directory

// Basic translation
const saveButton = t('ui.buttons.save');

// With fallback
const customText = t('custom.key', 'Default Text');

// Dynamic content
const welcomeMessage = t('ui.welcome', `Welcome, ${userName}!`);
```

### Function Signature

```typescript
/**
 * Translate a key to the current language
 * @param {string} key - Translation key (dot notation)
 * @param {string} fallback - Fallback text if key not found
 * @param {Object} params - Parameters for dynamic content
 * @returns {string} Translated text
 */
function t(key: string, fallback: string | null = null, params: Record<string, any> = {}): string {
    // Implementation details
}
```

### Advanced Usage

#### Parameter Substitution

```typescript
// Language file
export const translations = {
    messages: {
        itemCount: "{{count}}개의 항목이 있습니다"
    }
};

// Usage in Svelte
<script lang="ts">
  import { t } from '../i18n';
  let itemCount = 5;
</script>

<p>{t('messages.itemCount', null, { count: itemCount })}</p>
<!-- Result: "5개의 항목이 있습니다" -->
```

#### Conditional Translations

```typescript
// Language file
export const translations = {
    status: {
        online: "온라인",
        offline: "오프라인"
    }
};

// Usage in Svelte
<script lang="ts">
  import { t } from '../i18n';
  let isOnline = true;
</script>

<p>{t(`status.${isOnline ? 'online' : 'offline'}`)}</p>
```

## Implementation Patterns

### Component Integration (Svelte)

#### Direct Usage in Svelte Markup

Svelte components can directly use the `t()` function within their markup, leveraging Svelte's reactivity to update text when the language changes.

```svelte
<script lang="ts">
  import { t } from '../../i18n'; // Adjust path as needed
  import { currentLanguage } from '../../stores/settings'; // Assuming a store for current language

  // Reactive declaration to trigger re-render on language change
  $: lang = $currentLanguage;
</script>

<div class="settings-panel">
    <h2>{t('settings.title')}</h2>
    <label>{t('settings.api.provider')}</label>
    <input placeholder={t('settings.api.providerPlaceholder')}>
    <button>{t('ui.buttons.save')}</button>
</div>
```

#### Dynamic Content Updates

Svelte's reactivity system automatically handles updates when the language store changes. Components subscribed to the language store or using reactive declarations will re-render with the new translations.

```svelte
<script lang="ts">
  import { t } from '../../i18n';
  import { currentLanguage } from '../../stores/settings';

  // Reactive declaration: whenever $currentLanguage changes, this block re-runs
  $: {
    console.log(`Language changed to: ${$currentLanguage}`);
    // Any logic here that depends on the language will reactively update
  }
</script>

<p>{t('ui.welcomeMessage', null, { name: 'User' })}</p>
```

### API Integration

#### Error Message Translation

```typescript
// API handler (e.g., in a service file)
import { t } from '../i18n';

async function handleAPICall() {
    try {
        const response = await fetch(apiUrl);
        if (!response.ok) {
            throw new Error(t('api.errors.requestFailed'));
        }
    } catch (error) {
        console.error(t('api.errors.networkError'), error);
        // Assuming a notification service exists
        showNotification(t('api.errors.networkError'));
    }
}
```

#### Success Messages

```typescript
import { t } from '../i18n';

function saveSettings(settings: any) {
    try {
        // Assuming a storage service exists
        storage.save(settings);
        showNotification(t('api.success.settingsSaved'));
    } catch (error) {
        showNotification(t('api.errors.saveFailed'));
    }
}
```

### Modal Components (Svelte)

```svelte
<script lang="ts">
  import { t } from '../../i18n';
  export let action: string;
</script>

<div class="modal-content">
    <h3>{t('modal.confirmation.title')}</h3>
    <p>{t(`modal.confirmation.${action}Message`)}</p>
    <div class="modal-actions">
        <button class="confirm">{t('ui.buttons.confirm')}</button>
        <button class="cancel">{t('ui.buttons.cancel')}</button>
    </div>
</div>
```

## Adding New Languages

### Step 1: Create Language File

Create a new TypeScript file in `frontend/src/language/` following the naming pattern:

```typescript
// frontend/src/language/fr.ts (for French)
export const translations = {
    // Copy structure from ko.ts or en.ts
    ui: {
        buttons: {
            save: "Enregistrer",
            cancel: "Annuler",
            delete: "Supprimer"
        }
        // ... complete all translations
    }
    // ... complete all sections
};
```

### Step 2: Update i18n Configuration

Add the new language to the i18n system in `frontend/src/i18n.ts`:

```typescript
// frontend/src/i18n.ts
import { translations as ko } from './language/ko';
import { translations as en } from './language/en';
import { translations as fr } from './language/fr'; // Add new import

const languages = {
    ko,
    en,
    fr  // Add new language
};

const languageNames = {
    ko: '한국어',
    en: 'English',
    fr: 'Français'  // Add display name
};
```

### Step 3: Update Language Selector (Svelte Component)

Modify the Svelte component responsible for language selection (e.g., `AppearanceSettings.svelte` or `MobileSettings.svelte`) to include the new language option.

```svelte
<script lang="ts">
  import { t } from '../../i18n';
  import { currentLanguage } from '../../stores/settings';
  import { languageNames } from '../../i18n';

  function setLanguage(lang: string) {
    currentLanguage.set(lang);
  }
</script>

<div class="language-selector">
  {#each Object.entries(languageNames) as [code, name]}
    <button
      class:active={$currentLanguage === code}
      on:click={() => setLanguage(code)}
    >
      {name}
    </button>
  {/each}
</div>
```

### Step 4: Translation Guidelines

When translating to a new language:

1. **Maintain Context**: Understand the context of each key before translating
2. **Consistent Terminology**: Use consistent terms throughout the application
3. **Cultural Adaptation**: Adapt content to cultural norms when appropriate
4. **Technical Terms**: Keep technical terms consistent or use widely accepted translations
5. **Length Considerations**: Consider UI space constraints for longer languages

## Best Practices

### Translation Keys

1. **Descriptive Keys**: Use clear, descriptive key names
   ```typescript
   // Good
   'settings.api.providerSelectionTitle'
   
   // Avoid
   'apiTitle'
   ```

2. **Hierarchical Organization**: Group related translations
   ```typescript
   settings: {
       api: { /* API-related settings */ },
       appearance: { /* Appearance settings */ },
       character: { /* Character settings */ }
   }
   ```

3. **Avoid Hardcoded Text**: Always use translation keys for user-facing text
   ```typescript
   // Good
   element.textContent = t('ui.messages.success');
   
   // Avoid
   element.textContent = 'Success!';
   ```

### Performance Optimization

1. **Lazy Loading**: Load only the current language
2. **Caching**: Cache translations to avoid repeated lookups
3. **Batch Updates**: Update multiple elements together when language changes

### Error Handling

1. **Graceful Fallbacks**: Provide meaningful fallbacks
   ```typescript
   function t(key: string, fallback: string | null = null): string {
       const translation = getTranslation(key);
       return translation || fallback || key;
   }
   ```

2. **Missing Translation Logging**: Log missing translations for debugging
   ```typescript
   if (!translation) {
       console.warn(`Missing translation for key: ${key}`);
   }
   ```

### Real-time Updates (Svelte Reactivity)

Svelte's reactivity system inherently handles real-time updates when the language changes. By using the `t()` function within Svelte components and ensuring the `currentLanguage` store is updated, the UI will automatically re-render with the new translations.

```svelte
<script lang="ts">
  import { t } from '../i18n';
  import { currentLanguage } from '../stores/settings';

  // The component will reactively update when $currentLanguage changes
</script>

<h1>{t('ui.welcomeMessage')}</h1>
<p>{t('ui.currentLanguage', null, { lang: $currentLanguage })}</p>
```

## Troubleshooting

### Common Issues

#### 1. Missing Translations
**Problem**: Text displays as key instead of translated text
**Solution**: Check if the key exists in the current language file and that the path to `t()` is correct.

```typescript
// Debug missing translation
console.log('Translation exists:', translations[currentLanguage]?.ui?.buttons?.save);
```

#### 2. Language Not Switching
**Problem**: UI doesn't update after language change
**Solution**: Ensure the `currentLanguage` Svelte store is being correctly updated when the user selects a new language. Components using `t()` or subscribing to `currentLanguage` should reactively update.

```typescript
// Example of updating the language store
import { currentLanguage } from '../stores/settings';

function changeLanguage(newLanguage: string) {
    currentLanguage.set(newLanguage); // This will trigger Svelte's reactivity
}
```

#### 3. Parameter Substitution Not Working
**Problem**: Parameters like `{{count}}` not being replaced
**Solution**: Check parameter syntax in the language file and ensure parameters are correctly passed to the `t()` function.

```typescript
// Correct usage
t('messages.itemCount', null, { count: 5 });

// Check parameter syntax in language file
itemCount: "Found {{count}} items"
```

#### 4. Inconsistent Translations
**Problem**: Same concept translated differently in different parts
**Solution**: Create a translation glossary and use consistent terms.

### Debugging Tools

1. **Translation Key Inspector**: Add data attributes to track translation keys (can be done in Svelte components).
   ```svelte
   <p data-translation-key="ui.welcomeMessage">{t('ui.welcomeMessage')}</p>
   ```

2. **Missing Translation Reporter**: Log all missing translations (can be integrated into the `t()` function).
   ```typescript
   const missingTranslations = new Set<string>();
   
   function t(key: string, fallback: string | null = null, params: Record<string, any> = {}): string {
       const translation = getTranslation(key);
       if (!translation) {
           missingTranslations.add(key);
           console.warn(`Missing translation for key: ${key}`);
       }
       // ... rest of the t() implementation
       return translation || fallback || key;
   }
   ```

3. **Language Coverage Analysis**: Check translation completeness.
   ```typescript
   function analyzeTranslationCoverage(referenceLanguage: string, targetLanguage: string) {
       const missing: string[] = [];
       // Compare language files and report missing keys
       return missing;
   }
   ```

## Conclusion

ArisuTalk's internationalization system provides:
- **Comprehensive Coverage**: All user-facing text is translatable
- **Real-time Switching**: Instant language changes enhance user experience, powered by Svelte's reactivity
- **Developer-Friendly**: Easy to use translation functions and clear patterns
- **Extensible Architecture**: Simple to add new languages
- **Performance Optimized**: Efficient translation lookup and caching

By following this guide, developers can effectively work with the i18n system, add new languages, and maintain high-quality translations across the application.