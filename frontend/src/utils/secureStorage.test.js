import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Mock dependencies
vi.mock('./crypto.js', () => ({
    encryptText: vi.fn(),
    decryptText: vi.fn(),
    generateMasterPassword: vi.fn().mockReturnValue('new-random-password'),
}));

vi.mock('../storage.js', () => ({
    loadFromBrowserStorage: vi.fn(),
    saveToBrowserStorage: vi.fn(),
}));

vi.mock('../i18n.js', () => ({
    t: key => key, // Simple mock that returns the key
}));

// Mock sessionStorage
const sessionStorageMock = (() => {
    let store = {};
    return {
        getItem: (key) => store[key] || null,
        setItem: (key, value) => { store[key] = value.toString(); },
        clear: () => { store = {}; },
        removeItem: (key) => { delete store[key]; },
    };
})();
Object.defineProperty(global, 'sessionStorage', { value: sessionStorageMock });


// Dynamically import the module to use mocks
let SecureStorageManager;
let secureStorage;
let crypto, storage;

beforeEach(async () => {
    // Reset mocks and storage before each test
    vi.clearAllMocks();
    sessionStorage.clear();

    // Import mocked modules
    crypto = await import('./crypto.js');
    storage = await import('../storage.js');

    // Re-import the module to get a fresh instance with new mocks
    const module = await import('./secureStorage.js');
    SecureStorageManager = module.SecureStorageManager;
    // We need to create a new instance for each test to isolate them
    secureStorage = new SecureStorageManager();
});


describe('SecureStorageManager', () => {

    describe('initialize', () => {
        it('should perform first-time setup if no existing encryption', async () => {
            storage.loadFromBrowserStorage.mockResolvedValue(false);
            crypto.encryptText.mockResolvedValue('encrypted-test');

            const result = await secureStorage.initialize();

            expect(result).toBe(true);
            expect(secureStorage.encryptionEnabled).toBe(true);
            expect(crypto.generateMasterPassword).toHaveBeenCalled();
            expect(secureStorage.masterPassword).toBe('new-random-password');
            expect(storage.saveToBrowserStorage).toHaveBeenCalledWith('personaChat_masterPasswordHint_v1', 'secureStorage.autoGeneratedHint');
            expect(storage.saveToBrowserStorage).toHaveBeenCalledWith('personaChat_encryptionEnabled_v1', true);
        });

        it('should restore from session if encryption exists and session is valid', async () => {
            storage.loadFromBrowserStorage.mockResolvedValue(true);
            sessionStorage.setItem('personaChat_sessionMasterPassword', 'session-password');

            const result = await secureStorage.initialize();

            expect(result).toBe(true);
            expect(secureStorage.encryptionEnabled).toBe(true);
            expect(secureStorage.masterPassword).toBe('session-password');
            expect(crypto.generateMasterPassword).not.toHaveBeenCalled();
        });

        it('should regenerate password if session expired', async () => {
            storage.loadFromBrowserStorage.mockResolvedValue(true);
            // No session password

            const result = await secureStorage.initialize();

            expect(result).toBe(true);
            expect(secureStorage.encryptionEnabled).toBe(true);
            expect(crypto.generateMasterPassword).toHaveBeenCalled();
            expect(secureStorage.masterPassword).toBe('new-random-password');
            expect(sessionStorage.getItem('personaChat_sessionMasterPassword')).toBe('new-random-password');
        });
    });

    describe('setupEncryption', () => {
        it('should set up encryption successfully', async () => {
            crypto.encryptText.mockResolvedValue('encrypted-test');
            const result = await secureStorage.setupEncryption('my-password', 'my-hint');

            expect(result).toBe(true);
            expect(secureStorage.masterPassword).toBe('my-password');
            expect(secureStorage.encryptionEnabled).toBe(true);
            expect(sessionStorage.getItem('personaChat_sessionMasterPassword')).toBe('my-password');
            expect(storage.saveToBrowserStorage).toHaveBeenCalledWith('personaChat_masterPasswordHint_v1', 'my-hint');
            expect(storage.saveToBrowserStorage).toHaveBeenCalledWith('personaChat_encryptionEnabled_v1', true);
        });

        it('should throw if encryption test fails', async () => {
            crypto.encryptText.mockRejectedValue(new Error('Crypto Fail'));
            await expect(secureStorage.setupEncryption('my-password')).rejects.toThrow('secureStorage.setupEncryptionFailed');
        });
    });

    describe('API Configs', () => {
        beforeEach(async () => {
            // Reset the mock to a successful state for these tests
            crypto.encryptText.mockResolvedValue('encrypted-data');
            // Ensure manager is initialized with a password for these tests
            await secureStorage.setupEncryption('master-pass');
        });

        it('saveApiConfigs should encrypt and save data', async () => {
            const configs = { key: 'value' };
            crypto.encryptText.mockResolvedValue('encrypted-data');

            await secureStorage.saveApiConfigs(configs);

            expect(crypto.encryptText).toHaveBeenCalledWith(JSON.stringify(configs), 'master-pass');
            expect(storage.saveToBrowserStorage).toHaveBeenCalledWith('personaChat_encryptedApiConfigs_v1', 'encrypted-data');
        });

        it('loadApiConfigs should load and decrypt data', async () => {
            const configs = { key: 'value' };
            storage.loadFromBrowserStorage.mockResolvedValue('encrypted-data');
            crypto.decryptText.mockResolvedValue(JSON.stringify(configs));

            const result = await secureStorage.loadApiConfigs();

            expect(storage.loadFromBrowserStorage).toHaveBeenCalledWith('personaChat_encryptedApiConfigs_v1', null);
            expect(crypto.decryptText).toHaveBeenCalledWith('encrypted-data', 'master-pass');
            expect(result).toEqual(configs);
        });

        it('loadApiConfigs should return empty object if no stored data', async () => {
            storage.loadFromBrowserStorage.mockResolvedValue(null);
            const result = await secureStorage.loadApiConfigs();
            expect(result).toEqual({});
            expect(crypto.decryptText).not.toHaveBeenCalled();
        });

        it('loadApiConfigs should return empty object on decryption failure', async () => {
            storage.loadFromBrowserStorage.mockResolvedValue('bad-encrypted-data');
            crypto.decryptText.mockRejectedValue(new Error('Decrypt Fail'));
            const result = await secureStorage.loadApiConfigs();
            expect(result).toEqual({});
        });
    });

    describe('getPasswordHint', () => {
        it('should return the stored password hint', async () => {
            storage.loadFromBrowserStorage.mockResolvedValue('my-secret-hint');
            const hint = await secureStorage.getPasswordHint();
            expect(hint).toBe('my-secret-hint');
            expect(storage.loadFromBrowserStorage).toHaveBeenCalledWith('personaChat_masterPasswordHint_v1', '');
        });
    });
});
